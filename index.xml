<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>alexgb1</title>
    <link>https://agbuzneanu.com/</link>
    <description>Recent content on alexgb1</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© {year}</copyright>
    <lastBuildDate>Mon, 28 Dec 2020 11:13:43 +0100</lastBuildDate>
    
	<atom:link href="https://agbuzneanu.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Secret Sharing</title>
      <link>https://agbuzneanu.com/blog/secret-sharing/</link>
      <pubDate>Mon, 28 Dec 2020 11:13:43 +0100</pubDate>
      
      <guid>https://agbuzneanu.com/blog/secret-sharing/</guid>
      <description>The general idea of secret sharing begins with a secret which is divided into multiple pieces called shares. Each share is assigned to a user in such a manner that a given subset of shares from users can be used to reconstruct the original secret.
The motivation for this concept is related to the ability to safeguard cryptographic keys from loss or exposure. Secret sharing schemes are multi-party protocols related to the key establishment, where for example a private key in an asymmetric cryptosystem can be split between multiple entities for safely controlling decryption or signature creation.</description>
    </item>
    
    <item>
      <title>Your API as Data</title>
      <link>https://agbuzneanu.com/blog/your-api-as-data/</link>
      <pubDate>Sun, 13 Sep 2020 10:51:31 +0100</pubDate>
      
      <guid>https://agbuzneanu.com/blog/your-api-as-data/</guid>
      <description>If you are interested in the correctness of your Web API, you should consider building a strongly typed integration between the client and the server.
Just the usual In most cases, defining an API and using it can be quite prone to errors.
Every Scala HTTP library has its own approach in building and defining endpoints, requests and responses which can become tedious in maintaining.
Morever, there&amp;rsquo;s no support to properly document the APIs, this means that the documentation is manually defined which will eventually lead to integration errors due to becoming outdated or to simple mistakes.</description>
    </item>
    
    <item>
      <title>Faster Polynomial Evaluation</title>
      <link>https://agbuzneanu.com/blog/faster-polynomial-evaluation/</link>
      <pubDate>Sun, 06 Sep 2020 12:15:14 +0100</pubDate>
      
      <guid>https://agbuzneanu.com/blog/faster-polynomial-evaluation/</guid>
      <description>This might not be one of your daily problems. Evaluating polynomials seems to be a simple task until the coefficients become big numbers, e.g. 1024 bits or more, and could impact your whole software component.
Classic evaluation A simple way to evaluate a polynomial is:
def classicCompute(variable: BigInt): BigInt = { coefficients .zipWithIndex .foldLeft(BigInt(0)) { case (accumulator, (coefficient, i)) =&amp;gt; accumulator + coefficient * variable.pow(i) } }  Optimized evaluation In order to optimize a polynomial evaluation, one could use Horner&amp;rsquo;s method, which implies a significant improvement when using big numbers.</description>
    </item>
    
  </channel>
</rss>